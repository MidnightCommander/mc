# Author   : Sergei Trofimovich <slyfox@inbox.ru>
# Language : haskell
#
# 'Syntax rules for the C and the C++ programming languages' is taken as base
# (haskell compilers support CPP macros)
#
# haskell keywords and reserved symbols are grabbed from ghc-6.10.1/compiler/parser/Lexer.hs

context default

# haskell keywords

#   reserved keywords:

#   unused symbols
    keyword whole _\[0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\] brightmagenta

    keyword whole as brightyellow
    keyword whole case brightyellow
    keyword whole class brightyellow
    keyword whole data brightyellow
    keyword whole default brightyellow
    keyword whole deriving brightyellow
    keyword whole do brightyellow
    keyword whole else brightyellow
    keyword whole hiding brightyellow
    keyword whole if brightyellow
    keyword whole import brightyellow
    keyword whole in brightyellow
    keyword whole infix brightyellow
    keyword whole infixl brightyellow
    keyword whole infixr brightyellow
    keyword whole instance brightyellow
    keyword whole let brightyellow
    keyword whole module brightyellow
    keyword whole newtype brightyellow
    keyword whole of brightyellow
    keyword whole qualified brightyellow
    keyword whole then brightyellow
    keyword whole type brightyellow
    keyword whole where brightyellow

#   extension keywords
    keyword whole forall brightyellow
    keyword whole mdo brightyellow
    keyword whole family brightyellow
    keyword whole group brightyellow
    keyword whole by brightyellow
    keyword whole using brightyellow

#   ffi
    keyword whole foreign brightyellow
    keyword whole export brightyellow
    keyword whole label brightyellow
    keyword whole dynamic brightyellow
    keyword whole safe brightyellow
    keyword whole threadsafe brightyellow
    keyword whole unsafe brightyellow
    keyword whole stdcall brightyellow
    keyword whole ccall brightyellow
    keyword whole dotnet brightyellow

    keyword whole rec brightyellow
    keyword whole proc brightyellow

#   other
    keyword . brightwhite
#    keyword whole .. brightwhite

#   unboxed (started from upcase)
    keyword whole \{ABCDEFGHIJKLMNOPQRSTUVWXYZ\}\[0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\]# brightwhite
#   types/modules
    keyword whole \{ABCDEFGHIJKLMNOPQRSTUVWXYZ\}\[0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\] brightwhite

# C keywords (TODO: remove unused in haskell source)
    keyword whole auto brightyellow
    keyword whole break brightyellow
    keyword whole case brightyellow
    keyword whole char brightyellow
    keyword whole const brightyellow
    keyword whole continue brightyellow
    keyword whole do brightyellow
    keyword whole double brightyellow
    keyword whole else brightyellow
    keyword whole enum brightyellow
    keyword whole extern brightyellow
    keyword whole float brightyellow
    keyword whole for brightyellow
    keyword whole goto brightyellow
    keyword whole if brightyellow
    keyword whole int brightyellow
    keyword whole long brightyellow
    keyword whole register brightyellow
    keyword whole return brightyellow
    keyword whole short brightyellow
    keyword whole signed brightyellow
    keyword whole sizeof brightyellow
    keyword whole static brightyellow
    keyword whole struct brightyellow
    keyword whole switch brightyellow
    keyword whole typedef brightyellow
    keyword whole union brightyellow
    keyword whole unsigned brightyellow
    keyword whole void brightyellow
    keyword whole volatile brightyellow
    keyword whole while brightyellow
    keyword whole asm brightyellow
    keyword whole inline brightyellow
    keyword whole wchar_t brightyellow
    keyword whole ... brightyellow
    keyword whole linestart \{\s\t\}\[\s\t\]#*\n brightmagenta
    keyword whole \[\s\t\]default brightyellow
    keyword whole linestart \[\s\t\]\{ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\}\[0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\]: cyan

#digits
    keyword whole 0\{xX\}\{0123456789abcdefABCDEF\}\[0123456789abcdefABCDEF\] brightgreen
    keyword whole \{0123456789\}\[0123456789\] brightgreen
    keyword whole \[0123456789\]\.\{0123456789\}\[0123456789\] brightgreen
    keyword whole \{0123456789\}\[0123456789\]\.\[0123456789\] brightgreen
    keyword whole \{0123456789\}\[0123456789\]\{eE\}\{0123456789\}\[0123456789\] brightgreen
    keyword whole \{0123456789\}\[0123456789\]\{eE\}\{\-\+\}\{0123456789\}\[0123456789\] brightgreen
    keyword whole \{0123456789\}\[0123456789\]\.\{0123456789\}\[0123456789\]\{eE\}\{0123456789\}\[0123456789\] brightgreen
    keyword whole \{0123456789\}\[0123456789\]\.\{0123456789\}\[0123456789\]\{eE\}\{\-\+\}\{0123456789\}\[0123456789\] brightgreen

#comments
    keyword {- yellow
    keyword -} yellow
    keyword -- yellow

    keyword \*/ yellow
    keyword /\* yellow
    keyword // yellow

    keyword '\\\{"abtnvfr\}' brightgreen

#haskell standalone char escapes
    keyword '\\NUL' brightgreen
    keyword '\\SOH' brightgreen
    keyword '\\STX' brightgreen
    keyword '\\ETX' brightgreen
    keyword '\\EOT' brightgreen
    keyword '\\ENQ' brightgreen
    keyword '\\ACK' brightgreen
    keyword '\\BEL' brightgreen
    keyword '\\BS' brightgreen
    keyword '\\HT' brightgreen
    keyword '\\LF' brightgreen
    keyword '\\VT' brightgreen
    keyword '\\FF' brightgreen
    keyword '\\CR' brightgreen
    keyword '\\SO' brightgreen
    keyword '\\SI' brightgreen
    keyword '\\DLE' brightgreen
    keyword '\\DC1' brightgreen
    keyword '\\DC2' brightgreen
    keyword '\\DC3' brightgreen
    keyword '\\DC4' brightgreen
    keyword '\\NAK' brightgreen
    keyword '\\SYN' brightgreen
    keyword '\\ETB' brightgreen
    keyword '\\CAN' brightgreen
    keyword '\\EM' brightgreen
    keyword '\\SUB' brightgreen
    keyword '\\ESC' brightgreen
    keyword '\\FS' brightgreen
    keyword '\\GS' brightgreen
    keyword '\\RS' brightgreen
    keyword '\\US' brightgreen
    keyword '\\SP' brightgreen
    keyword '\\DEL' brightgreen

    keyword '\\\{0123\}\{01234567\}\{01234567\}' brightgreen
    keyword '\\'' brightgreen
    keyword '\\\\' brightgreen
    keyword '\\0' brightgreen
    keyword '\{\s!"#$%&()\*\+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\}' brightgreen

# some punctuation characters
    keyword whole $ brightyellow
    keyword whole ! brightwhite
    keyword whole && brightwhite
    keyword whole \* brightyellow
    keyword whole \+ brightyellow
    keyword whole / brightyellow
    keyword whole < brightyellow
    keyword whole > brightyellow
    keyword whole ^ brightwhite
    keyword whole || brightwhite
    keyword whole | brightwhite

    keyword ~ brightwhite
    keyword , brightcyan
    keyword - brightyellow
    keyword : brightcyan
    keyword ; brightyellow
    keyword = brightyellow
    keyword { brightwhite
    keyword } brightwhite
    keyword [ brightcyan
    keyword ] brightcyan
    keyword ( brightcyan
    keyword ) brightcyan

# comments
context exclusive /\* \*/ yellow
    spellcheck

context exclusive {-# #-} green
    spellcheck

context exclusive {- -} yellow
    spellcheck

context exclusive // \n yellow
    spellcheck

context exclusive \-\- \n yellow
    spellcheck

# C macros
context linestart # \n brightred
    keyword \\\n brightyellow
    keyword /\**\*/ yellow
    keyword //*\n yellow
    keyword "+" red
    keyword <+> red


context " " green
    spellcheck

#haskell escapes in ""s
    keyword \\NUL brightgreen
    keyword \\SOH brightgreen
    keyword \\STX brightgreen
    keyword \\ETX brightgreen
    keyword \\EOT brightgreen
    keyword \\ENQ brightgreen
    keyword \\ACK brightgreen
    keyword \\BEL brightgreen
    keyword \\BS brightgreen
    keyword \\HT brightgreen
    keyword \\LF brightgreen
    keyword \\VT brightgreen
    keyword \\FF brightgreen
    keyword \\CR brightgreen
    keyword \\SO brightgreen
    keyword \\SI brightgreen
    keyword \\DLE brightgreen
    keyword \\DC1 brightgreen
    keyword \\DC2 brightgreen
    keyword \\DC3 brightgreen
    keyword \\DC4 brightgreen
    keyword \\NAK brightgreen
    keyword \\SYN brightgreen
    keyword \\ETB brightgreen
    keyword \\CAN brightgreen
    keyword \\EM brightgreen
    keyword \\SUB brightgreen
    keyword \\ESC brightgreen
    keyword \\FS brightgreen
    keyword \\GS brightgreen
    keyword \\RS brightgreen
    keyword \\US brightgreen
    keyword \\SP brightgreen
    keyword \\DEL brightgreen

    keyword \\" brightgreen
    keyword %% brightgreen
    keyword %\[#0\s-\+,\]\[0123456789\*\]\[.\]\[0123456789\*\]\[L\]\{eEfgGoxX\} brightgreen
    keyword %\[0\s-\+,\]\[0123456789\*\]\[.\]\[0123456789\*\]\[hl\]\{diuxX\} brightgreen
    keyword %\[hl\]n brightgreen
    keyword %\[-\]\[0123456789\*\]\[.\]\[0123456789\*\]s brightgreen
    keyword %[*] brightgreen
    keyword %c brightgreen
    keyword %p brightgreen
    keyword \\\{0123\}\{01234567\}\{01234567\} brightgreen
    keyword \\\\ brightgreen
    keyword \\' brightgreen
    keyword \\\{abtnvfr\} brightgreen

# infix binop
context exclusive ` ` brightwhite
